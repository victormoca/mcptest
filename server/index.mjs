import express from 'express';import cors from 'cors';import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';import { z } from 'zod';import { generateSales } from './sales-data.mjs';const SERVER_METADATA = {  name: 'mcp-sales-demo',  version: '1.0.0',  description: 'Servidor MCP de ejemplo que entrega 100 ventas aleatorias',  websiteUrl: 'https://localhost',};const RESOURCE_URI = 'mcp://ventas/records';const createServer = () => {  const server = new McpServer(SERVER_METADATA, {    capabilities: {      logging: {},    },  });  server.resource(    'sales-dataset',    RESOURCE_URI,    {      mimeType: 'application/json',      name: 'Ventas aleatorias',      description: 'Listado sintético de ventas para pruebas MCP',    },    async () => {      const records = generateSales(100);      return {        contents: [          {            uri: RESOURCE_URI,            mimeType: 'application/json',            text: JSON.stringify(              {                generatedAt: new Date().toISOString(),                total: records.length,                records,              },              null,              2,            ),          },        ],      };    },  );  server.tool(    'list-sales',    'Devuelve un lote de ventas aleatorias',    {      count: z        .number()        .min(1)        .max(500)        .describe('Cantidad de registros aleatorios a generar (default 100)')        .optional(),    },    async ({ count }) => {      const records = generateSales(count ?? 100);      return {        content: [          {            type: 'text',            text: JSON.stringify(              {                generatedAt: new Date().toISOString(),                total: records.length,                records,              },              null,              2,            ),          },        ],      };    },  );  return server;};const app = express();app.use(express.json());app.use(  cors({    origin: '*',    exposedHeaders: ['Mcp-Session-Id'],  }),);app.post('/mcp', async (req, res) => {  const server = createServer();  try {    const transport = new StreamableHTTPServerTransport({      sessionIdGenerator: undefined,    });    res.on('close', () => {      transport.close();      server.close();    });    await server.connect(transport);    await transport.handleRequest(req, res, req.body);  } catch (error) {    console.error('Error al manejar la solicitud MCP:', error);    if (!res.headersSent) {      res.status(500).json({        jsonrpc: '2.0',        error: {          code: -32603,          message: 'Internal server error',        },        id: null,      });    }  }});app.get('/mcp', (_, res) => {  res    .status(405)    .json({      jsonrpc: '2.0',      error: {        code: -32000,        message: 'Method not allowed. Use POST to interact with este servidor MCP.',      },      id: null,    });});app.delete('/mcp', (_, res) => {  res    .status(405)    .json({      jsonrpc: '2.0',      error: {        code: -32000,        message: 'Method not allowed en modo sin estado.',      },      id: null,    });});const PORT = process.env.PORT ? Number(process.env.PORT) : process.env.MCP_PORT ? Number(process.env.MCP_PORT) : 3333;const serverInstance = app.listen(PORT, () => {  console.log(`Servidor MCP de ventas escuchando en http://localhost:${PORT}/mcp`);});const shutdown = () => {  console.log('Cerrando servidor MCP...');  serverInstance.close(() => {    console.log('Servidor MCP detenido.');    process.exit(0);  });};process.on('SIGINT', shutdown);process.on('SIGTERM', shutdown);